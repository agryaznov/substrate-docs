---
title: Candle Auctions Workshop
slug: /tutorials/v3/candle
version: '3.0'
sideNav: candleWorkshop
section: tutorials
hideNav: true
category: candle auction workshop
keywords: candle, auction, ink, workshop
difficulty: 3
duration: 3 Hours
relevantSkills:
  - Rust
  - Smart Contracts
---


In this workshop, we will set up and perform two Candle Auctions: for a collection of NFTs and for a domain name. 
We will accomplish this with [ink!](https://github.com/paritytech/ink) smart contracts deployed on a Substrate chain. 

It is recommended (though not required) to pass through the [ink! Contracts Workshop](/tutorials/v3/ink-workshop/pt1/) tutorial before diving into this workshop.

That's being said, let's start! 

## Getting Started

Follow the
[official installation steps](/v3/getting-started/installation) to install the prerequisites.


Once you have accomplished that you will also need to run:

```bash
rustup component add rust-src --toolchain nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
```


<br />
<Message
  type={`gray`}
  title={`Note`}
  text={`Polkadot ecosystem projects are moving forward extremely fast! This means that new versions of modules and tools used in this workshop are being released regularly. To keep all parts working together smoothly and sustainable as described in this tutorial, please use **the exact versions** of modules being installed, as specified below.`}
/>


### 1. Substrate Contracts Node

We will use a pre-configured Substrate node with the built-in `contracts` pallet.

Install it with:  
```bash
cargo install contracts-node --git https://github.com/agryaznov/substrate-contracts-node.git --tag v0.3.1 --force --locked
```

Then launch it: 


```bash
substrate-contracts-node --dev --tmp
```

You should see it started to produce blocks like this:  

![Substrate Smart Contracts Node](/assets/tutorials/ink-workshop/start-canvas-node.png)

Leave it running to the end of this workshop. 


### 2. PolkadotJS Apps

To keep consistency between runtime modules being used in our node and the UI, let's freeze the version of PolkadotJS Apps we use by cheking it out and running it locally. 

For that, clone the repo:  

```bash
git clone --depth 1 --branch v0.98.1 https://github.com/polkadot-js/apps.git
```

Then build it and run:  
```bash
cd apps/
yarn
yarn run start
```

You can open [http://localhost:3000/#/explorer](http://localhost:3000/#/explorer) and see apps runnnig and showing blocks being produced by our node. Keep this apps running to the end of this workshop.



### 3. ink! CLI

Next tool we will install is **ink!** command line utility which makes building Substrate smart contract projects easier.

As a prerequisite for this tool you need to install the **binaryen** package, which is used to optimize the *WebAssembly* bytecode of the contract.

If you are using Ubuntu, Debian or MacOS, you could install it directly:

```bash
# For Ubuntu or Debian users
sudo apt install binaryen
# For MacOS users
brew install binaryen
```

<br />
<Message
  type={`gray`}
  title={`Note`}
  text={`If you're unable to find a version of \`binaryen\` compatible with your OS, you can [download the binary release directly](https://github.com/WebAssembly/binaryen/releases).`}
/>

After you've installed the package execute:

```bash
cargo install cargo-contract --vers ^0.16 --force --locked
```

You can then use `cargo contract --help` to start exploring the commands made available to you.


### 4. Contracts Sources

#### Candle Auction
Clone the [*candle-auction-ink*](https://github.com/agryaznov/candle-auction-ink) repository somewhere else outside *ink* folder we've checked out above:

```bash
git clone -b tutorial https://github.com/agryaznov/candle-auction-ink.git
```

Let's start by taking the contract source version which supports single subject: *ERC721*, run an auction with it and then improve it to support another subject as well. 

Check out this starter version by the command:

```bash 
cd candle-auction-ink
git checkout tutorial-step-1
```

And build the contract: 

```bash
cargo +nightly contract build
```

#### ERC721

We will use our [own slightly modified version](https://github.com/agryaznov/ink/blob/candle-auction/examples/erc721/lib.rs#L168) of the contract codebase, which only adds an explicit human-readable [selector](https://paritytech.github.io/ink-docs/macros-attributes/selector/#controlling-the-messages-selector) to the message that will be invoked from inside our contract:

```rust
#[ink(message, selector = 0xFEEDBABE)]
pub fn set_approval_for_all(
	&mut self,
    to: AccountId,
    approved: bool,
) -> Result<(), Error> {
    self.approve_for_all(to, approved)?;
    Ok(())
}
```

Let's check out its sources:  

```bash
git clone -b candle-auction https://github.com/agryaznov/ink.git
```

Run tests:  

```bash
cd ink/examples/erc721
cargo +nightly test
```

And then build the contract:  
```bash
cargo +nightly contract build
```

As the result you should get the following compiled files:  

```
target/ink/
├── CACHEDIR.TAG
├── erc721.contract <-- we'll use this one for deploying
├── erc721.wasm
├── metadata.json
├── release
└── wasm32-unknown-unknown
```

#### DNS 

Same actions to build the contract sources. 

Run tests:  

```bash
cd ../dns
cargo +nightly test
```

And then build the contract:  
```bash
cargo +nightly contract build
```

As the result you should get the following compiled files:  

```
target/ink/
├── CACHEDIR.TAG
├── dns.contract <-- we'll use this one for deploying
├── dns.wasm
├── metadata.json
├── release
└── wasm32-unknown-unknown
```


## Candle Auction Basics

At the bottom, a candle auction is basically an English auction for which end time is not known apriori and is to be determined randomly. There weren't many tamed sources of randomness back then in 17-18th centuries, when auctions of this type were popular, and people used a 🕯️ candle for that. Auction started once a candle was lit and ended once its flame expired, hence the name of such an auction type.

The benefit of an auction run by candle is that it encourages participants to place their true bids from the very beggining of the auction, as there won't be a chance to perform snipping, effectively leading to win of a bidder who truly values the slot at most. What makes it even more useful for running on a blockhain, is that such an auction mechanics prevents front-running and neutralizes possible harmful effects of smart contracts being present among bidders (see [this blog post](https://polkadot.network/blog/research-update-the-case-for-candle-auctions/) for detailed explanations on that).

For that reason, this kind of an auction is being used for [Polkadot parachain slot allocations](https://wiki.polkadot.network/docs/learn-auction#mechanics-of-a-candle-auction). And what we will in essense do during this workhop is reproduce that same logic in miniature, namely in a smart contract. 

So, let's go ahead!

Basic logic is the following. Auction timing is splitted into two periods (or *phases*): _Opening_ and _Ending_.
We measure time in atomic units of its nature on chain, which are *blocks*.
Consider for instance this variant of an auction schedule:   

```
Example of an auction schedule:
[1][2][3][4][5][6][7][8][9][10][11][12][13]
  |  Opening  |        Ending         |
```

In this auction example, *Opening* phase lasts for blocks `2`-`5` and *Ending* phase lasts for blocks `6`-`12`.

As bidding transactions being included into blocks and the latter get sealed into the chain, we can treat this as if bids were made in consecutive *rounds*. Each round goes like just a short (with duration of one block) English auction, accepting ascending prices higher than the top price of a previous round. At the end, single one of these rounds will be randomly selected to become *decisive*, i.e. the winner of that round will become the winner of the whole auction. Important thing to mention here is that the round selection is done after all rounds have passed, in retrospective manner.

Bids are accepted during both periods, but only a single round inside *Ending* period could be selected as a *decisive* one.
All bids placed after the decisive round won't be counted, thereby not necessary the highest bid of whole auction wins. 
In the example above, blocks `6`, `7`, `8`, `...`, `11`, `12` correspond to bidding rounds `1`, `2`, `3`, `...`, `6`, `7`.  If it turns out that there is no bids in these rounds at all, then the top bid of whole *Opening* period wins. We can therefore say that the *Opening* period is effectively round `0`. 

## Auction Subject

Auction does not run just on its own, there should be a subject for it. In Polkadot's and Kusama's candle auctions the subjects are parachain leasing slots.  We design our candle auction smart contract that way so it is possible to run it on various subjects, depending on particular use case needs. In this workshop, we will setup auctions for an **_NFTs collection_** and for a **_domain name_**.

To make all the process run trustlessly on chain, the auction subjects should be some entities living and being managed fully on chain. This means that every subject implies a separate contract to represent its logic on chain. 

### *ERC721*

For *NFTs* we'll use a [slightly modified](https://github.com/agryaznov/ink/blob/candle-auction/examples/erc721/lib.rs#L168) *ERC721* contract example taken from [Ink repository](https://github.com/paritytech/ink/blob/v3.0.0-rc7/examples/erc721/lib.rs). 

<br />
<Message
  type={`yellow`}
  title={`Information`}
  text={`**ERC721** is an [Ethereum standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/) for Non-Fungible Tokens. You can *mint*, *transfer*, *approve* transfers on your behalf to someone else or even *burn* your NFTs with that contract. 
  
  Largest NFT marketplaces use this standard to trade artworks on it. If you've heard about million-dollar cyberpunk or monkey pic sold as an NFT, then know that under the hood it's a token minted with an *ERC721* (or sometimes its descedant *ERC1155*) contract.
  
**Ready to put your own masterpiece on an auction?** Keep following this workshop further on, that's **exactly what we'll do in a minutes below!**`}
/>


The *ERC721* contract will be invoked by different parties of the auction, including both *human* (or a program running off-chain which holds the private key) and *contract* accounts:  

+ *Artist* invokes [`mint()`](https://github.com/paritytech/ink/blob/v3.0.0-rc7/examples/erc721/lib.rs#L211) method to mint one or several tokens;
+ Before the Auction starts, he invokes [`transfer()`](https://github.com/paritytech/ink/blob/v3.0.0-rc7/examples/erc721/lib.rs#L187) to transfer the tokens he'd like to sale to the *Auction* contract;
+ Once the winner is determined, the *Auction* contract invokes [`set_approval_for_all()`](https://github.com/paritytech/ink/blob/v3.0.0-rc7/examples/erc721/lib.rs#L169) method to approve the *Winner* to transfer these tokens;
+ Finally the *Winner* invokes [`transfer_from()`](https://github.com/paritytech/ink/blob/v3.0.0-rc7/examples/erc721/lib.rs#L199) to transer these tokens to herself or whoever else she'd like to send it to. 

```bash
+---------+                       +---------+                        +---------+           +---------+
| Artist  |                       | ERC721  |                        | Auction |           | Winner  |
+---------+                       +---------+                        +---------+           +---------+
     |                                 |                                  |                     |
     | mint() NFTs                     |                                  |                     |
     |-------------------------------->|                                  |                     |
     | ------------\                   |                                  |                     |
     |-| Owns NFTs |                   |                                  |                     |
     | |-----------|                   |                                  |                     |
     |                                 |                                  |                     |
     |                                 |                                  |                     |
     |                                 |                                  |                     |
     |                                 |                                  |                     |
     |                                 |                                  |                     |
     |                                 |                                  |                     |
     | transfer() NFTs to Auction      |                                  |                     |
     |-------------------------------->|                                  |                     |
     |                                 |                    ------------\ |                     |
     |                                 |                    | Owns NFTs |-|                     |
     |                                 |                    |-----------| |                     |
     |                                 |                                  |                     |
     |                                 |                                  |               bid() |
     |                                 |                                  |<--------------------|
     |                                 |                                  |-------------------\ |
     |                                 |                                  || Wins the auction |-|
     |                                 |                                  ||------------------| |
     |                                 |                                  |                     |
     |                                 |      approve_for_all() to Winner |                     |
     |                                 |<---------------------------------|                     |
     |                                 |                                  |                     |
     |                                 |                     transfer_from() Auction to herself |
     |                                 |<-------------------------------------------------------|
     |                                 |                                  |       ------------\ |
     |                                 |                                  |       | Owns NFTs |-|
     |                                 |                                  |       |-----------| |
     |                                 |                                  |                     |
```
This sequence digaram demonstrates how different accounts comminicate with *ERC721* contract throughout the process. 

### Mint NFTs

As we are now familiar with the *ERC721* contract, let's deploy an instance of it and mint a couple NFTs to put on sale later on in the following chapters. 

Open [PolkadotJS apps /contract](http://localhost:3000/#/contracts) ) tab and click `Upload & deploy code`. Let's say Ferdie would be an artist who would like to sell NFTs of his artworks. Choose him as a deployment account, attach `erc721.contract` compiled above, put some *endownment* to it e.g. *1000 Units*, and deploy! 

Next, let's issue two non-fungible tokens with this contract. Click on the contract instance, select `mint()` message, set `Id=17` and send the transaction. 

![Mint a ERC721 Token](/assets/tutorials/candle-workshop/mint-nft.png)

Repeat just the same actions to mint another token with `Id=5`. 

Now that Ferdie has got some NFTs to sell, time comes to set up an auction for them!


## Auction Set Up

Not unlike we've done with *ERC721* contract in the previous section, let's deploy the compiled `candle_auction.contract` using *Polkadot JS Apps*.

![Deploy Auction Contract](/assets/tutorials/candle-workshop/candle-constructor-1.png)

Set the following contructor parameters:

+  `start_block`: `<empty> (default)`, which makes auction start at the next block after contract instantiation;
+  `opening_period`: `5`, to make *Opening* period last for five blocks;
+  `ending_period`: `25`, to make *Ending* period last for twenty-five blocks;
+  `subject`: `0`, just leave it for now, we'll need this in next section; 
+  `reward_contract_address`: `<ERC721 instantiated contract address>`

<br />
<Message
  type={`red`}
  title={`Warning`}
  text={`Total duration of this auction will be 30 blocks which is approximately 3 minutes. And it starts in just one block (~6 sec) after you've
  deployed it. **So hurry up to place some bids until the auction is closed**!`}
/>

Set `endownment` to `1000`, deploy the contract and move fast to the following section!

### Pass On the Subject Ownership

*Ferdie* should now transfer his precious NFT collection to the auction contract. For that, turn back to our *ERC721* contract and send `transfer()` transaction 

![Transfer NTF to auction](/assets/tutorials/candle-workshop/transfer-nft-to-auction.png)

Do this for both tokens `Id=5` and `Id=17`.

Ideally this should be done before the auction actually starts. In real case it shoudn't be a problem as auction is normally annonced in advance, and 
`start_block` would be set up to a block expected to appear some (reasonable) time after the contract instantiation. 


## Auction Run
Let's run a play in four roles:  

+ *Ferdie*, as we already know, is the auction owner;
+ *Alice*, *Bob* and *Eve* will be the bidders, who will compete to win the auction. 

### Bid

Everyone can observe the auction parameters and its current status in *PolkadotJS Apps*:   

![Auction View](/assets/tutorials/candle-workshop/auction-view.png)
 

Let's say Alice would like to participate in this auction. Before placing her bid, it makes sense for her to verify that the tokens she'd bid for are indeed owned by the auction contract instance. She can do this with `owner_of()` message to *ERC721* contract:  

![Ownership View](/assets/tutorials/candle-workshop/check-owner-is-auction.png)

Alright, Alice sees that the NFT tokens she wants to get are indeed owned by contract address `5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY`, which is set up to be rewarding contract of the auction. Now Alice can safely participate in bidding! Go ahead and send a bid now:  

![Alice Bids](/assets/tutorials/candle-workshop/alice_bids.png)

Newcomers, like Bob is, can now see that winning bid is Alice's *100 Units* and that auction is still going on (`EndingPeriod: 14` status means that it is in 14th block of the *Ending Period*):   

![Auction View 2](/assets/tutorials/candle-workshop/auction-view-2.png)

Go ahead now, and place a `110 Units` bid from Bob, following by a `120 Units` bid from *Eve*. 

As last block of the *Ending Period* passes by, auction is closed: no more bids are accepted! But that's not the end still, as we need to "blow that candle", i.e. randomly determine the decisive block and the winner.  Fot that, we have to wait untill chain randomness source *matures*.



### Wait For Rf Delay

It's time to take a break!  
Relax and have a cup of  ☕  while waiting for the auction status to become `RfDelay: n` with `n`>`81`. 

<br />
<Message
  type={`yellow`}
  title={`Information`}
  text={`Our auction contract allows you to configure the source of randomness (see its [entropy module](src/entropy.rs)). By default, it uses [ink_env::random()](https://docs.rs/ink_env/3.0.0-rc7/ink_env/fn.random.html) function which in turn utilizes [randomness-collective-flip](https://github.com/paritytech/substrate/blob/v3.0.0/frame/randomness-collective-flip/src/lib.rs#L113) module. The latter provides generator of low-influence random values based on the block hashes from the last 81 blocks. This means that when using this particular random function, it is required to wait at least **81 blocks** after the last block of *Ending* period until invoking the function to get a random block inside that period.`}
/>


Once `RfDelay > 81` you are ready to go and determine the winner!

### Find Winner

Winner determination is being made by figurative "*candle blowing*" with invoking the `find_winner()` message. 

It doesn't matter who calls it, could be any account who is ready to pay for gas required for that transaction. Let's imagine *Ferdie* can't wait to get his money for sold NFTs so he invokes it: 

![Find Winner](/assets/tutorials/candle-workshop/find_winner.png)


As a result, a block inside *Ending* period is selected to be the decisive one. Bidder who was winning that round becomes the auction winner, and the auction is finalized:

![Auction Ended](/assets/tutorials/candle-workshop/auction_ended.png)


In the case shown on the screenshots, Bob became the winner with his bid of *110 Units*. Note that while Eve bidded a larger amount, her bid happened to occur in some round after "candle went out", hence she lost. That's a vivid example of a candle auction result! 

### Claim Rewards

Once auction ended, every participant can claim his payout. 

#### Winner

Let the first goes the winner: Bob invokes `payout()` method:

![Bob Payout](/assets/tutorials/candle-workshop/bob_payout.png)


As a result he recieves an `approval_for_all` *ERC721* tokens belonging to Candle Auction contract to be transferred by himself:

![Is Approved For All](/assets/tutorials/candle-workshop/is_approved_for_all.png)


Let Bob transfer one of the tokens to himself:

![Bob Transfers NFT](/assets/tutorials/candle-workshop/nft_winner_transfer.png)


Make sure ownership transferral has been enforced: 

![Bob Owns NFT](/assets/tutorials/candle-workshop/nft_winner_owns.png)


Other token `Id=5` Bob could transfer later to whatever address he decides to, e.g. as a gift to a friend. 

#### Owner

Now invoke the `payout()` from *Ferdie* account. He should get the winner bid amount of `110 units`, which will be reflected by a `balances.Transfer` event being emmited:  

![Owner Payout](/assets/tutorials/candle-workshop/owner_payout.png)

#### Others

Calling the `payout()` by *Alice* and *Eve* should turn them being paid their bids back, which is `100` and `120` `Units` respectively. Go ahead and check that by yourself!

## Add New Rewarding Option
### *DNS*

The other possible auction subject could be a domain name. Imagine you've got a nice domain name and you'd like to put it on sale without involving third parties like greedy domain registrar companies.  Hopefully, in a future Internet this will work the following way: there will be automated transparent registrars in form of smart contracts, and domain registering and ownership trasferral operations will be processed through them. (*See [ENS](https://docs.ens.domains/) as a prominent example of such a system*). 

We have built the *DNS* contract sources in the [Getting Started](http://localhost:8001/tutorials/v3/candle#4-contracts-sources) section above. 

Let's now deploy it and register a domain name. You could do this alongside all previously deployed contracts. Or, to make things more clear, let's [restart our dev node](#1-substrate-contracts-node) (which clears storage) and remove all old contract instances from the *UI*:

![Clear old contract](/assets/tutorials/candle-workshop/contract_removal.png)

Then deploy new DNS contract: 

![DNS contract deployment-1](/assets/tutorials/candle-workshop/dns_deploy-1.png)
![DNS contract deployment-2](/assets/tutorials/candle-workshop/dns_deploy-2.png)

Once contract has been instantiated, invoke `register()` method to register a `0xBABE0000000000000000000000000000000000000000000000000000000000000000` domain name 

![Domain register](/assets/tutorials/candle-workshop/domain_register.png)


### Upgrade Auction Contract

Next, we need to add new rewarding option to our auction, which basically means adding the following rewarding function:

```rust
/// Pluggable reward logic: OPTION-2.    
/// Reward with domain name.  
/// Contract rewards an auction winner by transferring her auctioned
/// domain name using the dns contract.
///
/// Cross conract call to ERC721 set_approval_for_all() method,  
/// which is expected to have the selector: 0xFEEDDEED   
fn give_domain(&self, to: AccountId) {
    let selector = Selector::new([0xFE, 0xED, 0xDE, 0xED]);
    let input = ExecutionInput::new(selector)
        .push_arg(self.domain)
        .push_arg(to);

     self.invoke_contract(self.reward_contract_address, input);

     self.env().emit_event(Reward {
        to: to,
        subject: Subject::Domain(self.domain),
        contract: self.reward_contract_address,
     });
}
```

And *plug it in* by extending our auction `payout()` function as follows: 

```rust
/// Message to claim the payout.  
#[ink(message)]
pub fn payout(&mut self) {
    const REWARD_METHODS: [fn(&CandleAuction, to: AccountId); 2] =
        [CandleAuction::give_nft, CandleAuction::give_domain];
		
    let caller = self.env().caller();
    // invoke reward method
    self.pay_back(REWARD_METHODS[usize::from(self.subject)], caller);
}
```

Check out the full upgraded auction contract version and build it:

```bash 
cd candle-auction-ink
git checkout tutorial-step-2
cargo +nightly contract build
```

### Run

Next, deploy the new auction contract. In its contructor, specify the subject `1` and  the `domain` we have just registered:

![DNS auction deployment](/assets/tutorials/candle-workshop/candle-constructor-2.png)

Last but not the least, transfer the domain name from *Ferdie* account to this new contract instance. 

![Domain transfer](/assets/tutorials/candle-workshop/domain_transfer.png)

Now you are ready to run the candle auction for the domain name! Go ahead and run it just like we've done [above](http://localhost:8001/tutorials/v3/candle#auction-run) for *Ferdie's* NFT collection. 

Whooah, you've done it! 🎉 Congrats! In this workshop, you've learnt about candle auctions, and how to setup such an auction for a NFT collection and a domain name. 

As a postscript, let's consider briefly two topics necessary to be understood to run and participate in on-chain candle auctions confidently:  
+ Contract Verification, and
+ Randomness Source.

## Contract Verification

To utilize a smart contract *trustlessly*, you should be able to: 

1. Read and understand its [source code](https://github.com/agryaznov/candle-auction-ink). Or, at least, take its source code from some secured place (like Github) where community has audited it.  
And,  
2. Verify that the wasm bytecode being executed on chain while invoking a particular contract methods, is in fact built from that source code you've get in point 1. 

The latter could be accomplished the following way. In PolkadotJS Apps, go to [Developer -> Chain State -> Storage tab](http://localhost:3000/#/chainstate),  then select "_contracts_" state query and choose "[`ContractInfoOf`](https://github.com/paritytech/substrate/blob/v3.0.0/frame/contracts/src/lib.rs#L881)" storage field. Specify the _AccountID_ of the contract instance in question. In response you'll get a `contractInfo` data with the `codeHash` value. A smart contract code is stored on chain as a wasm bytecode, and _codeHash_ is its *blake2_256* hash. Therefore, it's enough to compare the code hashes to effectively vefify that the code being executed by this contract instance on chain is the same you get when you compile this contract by yourself. 

If you'd like to go even beyond that and get the bytecode of the contract instance, you could do this too by quering the [`PristineCode`](https://github.com/paritytech/substrate/blob/v3.0.0/frame/contracts/src/lib.rs#L873) storage value for that `codeHash`.

<br />
<Message
  type={`gray`}
  title={`Note`}
  text={`The same _Ink!_ source code built with different compiler versions results in different wasm bytecodes. Hence to verify a contract you'll need to build it using exactly **the same** compiler version as the contract owner did.`}
/>


## Change Randomness Source

There are currently two major sources of randomness which are ready to use on Substrate chains: 

1. *Randomness trait* implentation in [BABE pallet](https://docs.substrate.io/rustdocs/latest/pallet_babe/struct.CurrentBlockRandomness.html#method.random),  
  which uses VRFs.  
  **Note** that you can use this only if your chain runs on *BABE* consesus. [Contracts node](#1-substrate-contracts-node) which we used in this worshop runs on *AURA* consensus instead, hence this variant doesn't fit to be run on its chain. (*Read more on consensus mechanisms [here](https://docs.substrate.io/v3/advanced/consensus/#consensus-in-substrate)*). 
  
2. *Randomness trait* implentation in [Randomness Collective Flip pallet](https://github.com/paritytech/substrate/blob/v3.0.0/frame/randomness-collective-flip/src/lib.rs#L113).  
  This is the one which is actually used under the hood in this workshop.

Tricks and details of randomness implementation is out of the scope of this workshop. However, you can read through [Randomness](https://docs.substrate.io/v3/runtime/randomness/) docs section, which gives you a helpful overview of the topic. Also you can even go ahead and try to [implement your own random function inside a pallet](https://docs.substrate.io/how-to-guides/v3/pallet-design/randomness/). 

Whatever source of randomness you prefer to utilize, it can be "*plugged in*" into you candle auction logic in its [entropy module](https://github.com/agryaznov/candle-auction-ink/blob/master/src/entropy.rs).



## References

- [ink! Contracts Workshop](/tutorials/v3/ink-workshop/pt1/)
- [Candle Auctions on Ink](https://github.com/agryaznov/candle-auction-ink) repository and documentation
- [Research Update: The Case for Candle Auctions](https://polkadot.network/blog/research-update-the-case-for-candle-auctions/) blog post
- [Candle Auctions on Ink!: DIY NFT Sales](https://agryaznov.com/2021/12/06/candle-auction-ink/) blog post
